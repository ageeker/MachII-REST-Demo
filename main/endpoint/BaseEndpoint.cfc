<cfcomponent displayname="BaseEndpoint" output="false" extends="MachII.endpoints.rest.BaseEndpoint" hint="RESTFul Enpoint Base">
			
	<cffunction name="configure" access="public" returnType="Any">
		<cfreturn SUPER.configure() />
	</cffunction>

	<cffunction name="setSessionService" access="public" returntype="VOID" output="false">
		<cfargument name="SessionService" type="Demo201302.service.SessionService" required="true">
		<cfset variables.SessionService = arguments.SessionService />
	</cffunction>
	
	<cffunction name="handleRequest" access="public" returntype="void" output="true">
		<cfargument name="event" type="MachII.framework.Event" required="true" />

		<cfset var pathInfo = arguments.event.getArg("_requestMethod", "") />
		<cfset var httpMethod = arguments.event.getArg("_requestPathInfo", "") />
		<cfset var restUri = arguments.event.getArg("restUri") />
		<cfset var restUriMetaData = getMetaData(restUri) /> 
		<cfset var restResponseBody = "" />

		<cfif structKeyExists(restUriMetaData, "rest:authenticate") AND restUriMetaData["rest:authenticate"]>
			<cfset onAuthenticate(argumentCollection=arguments) />
		</cfif>

		<cfif IsObject(restUri)>
			<cfset restResponseBody = callEndpointFunction(restUri, event) />
			<cfset addContentTypeHeaderFromFormat(event.getArg("format", "")) />
			<cfsetting enablecfoutputonly="false" /><cfoutput>#restResponseBody#</cfoutput><cfsetting enablecfoutputonly="true" />
		<cfelse>
			<cfthrow type="MachII.endpoints.EndpointNotDefined" message="No REST URI was found for '#pathInfo#', httpMethod='#httpMethod#'." detail="" />
		</cfif>
	</cffunction>

	<cffunction name="onAuthenticate" access="public" returntype="void" output="false">
		<cfargument name="event" type="MachII.framework.Event" required="true" />

		<cfif NOT variables.sessionService.isUserLoggedOn()>
			<cfheader statuscode="401" statustext="Invalid User Session" />
			<cfthrow type="MachII.dashboard.endpoints.notAuthorized" message="Invalid User Session" />
		</cfif>
	</cffunction>

    <cffunction name="queryToArray" access="public" returntype="Array" output="false">
        <cfargument name="q" type="Query" required="true">
        <cfargument name="s" type="Numeric" required="false" default="1">

		<cfset temp = 0 />
		<cfset results = arrayNew(1) />
		<cfset columns = lCase(q.columnList) />
		<cfset startAt = min(arguments.s, q.recordCount) />

		<cfif q.recordCount EQ 0>
			<cfreturn results />
		</cfif>

		<cfloop index="i" from="#startAt#" to="#q.recordCount#">
			<cfset temp = structNew() />
			<cfloop index="col" list="#columns#">
				<cfset temp[col] = trim(lCase(q[col][i])) />
			</cfloop>
			
			<cfset arrayAppend(results, temp) />
		</cfloop>

       <cfreturn results />
    </cffunction>

    <cffunction name="queryRowToStruct" access="public" returntype="Struct" output="false">
        <cfargument name="q" type="Query" required="true">
        <cfargument name="r" type="Numeric" required="false" default="1">

		<cfset temp = 0 />
		<cfset results = arrayNew(1) />
		<cfset columns = lCase(q.columnList) />

		<cfset results = structNew() />
		<cfloop index="col" list="#columns#">
			<cfset results[col] = trim(lCase(q[col][arguments.r])) />
		</cfloop>

       <cfreturn results />
    </cffunction>

	<cffunction name="arrayOfStructSort" returntype="Array">
		<cfargument name="array" type="Array" required="true" />
		<cfargument name="key" type="String" required="true" />
		<cfargument name="sortType" type="String" default="textnocase" required="false" />
		<cfargument name="sortOrder" type="String" default="asc" required="false" />

		<cfset var i = "" />
		<cfset var results = arrayNew(1) />
		<cfset var sortTble = structNew() />

		<cfloop index="i" from="1" to="#arrayLen(arguments.array)#">
			<cfset sortTble[i] = arguments.array[i] />
		</cfloop>

		<cfloop index="i" array="#structSort(sortTble, arguments.sortType, arguments.sortOrder, "name")#">
			<cfset arrayAppend(results, arguments.array[i]) />
		</cfloop>

		<cfreturn results />
	</cffunction>

    <cffunction name="onException" access="public" returntype="void" output="true">
        <cfargument name="event" type="MachII.framework.Event" required="true">
        <cfargument name="cfcatch" type="any" required="true" hint="The cfcatch object generated by an exception.">

		<cfset var returnedError = structNew() />
		
		<cfset returnedError["type"] = arguments.cfcatch.getType() />
		<cfset returnedError["message"] = arguments.cfcatch.getMessage() />
		<cfset returnedError["tagContext"] = arguments.cfcatch.getTagContext() />
		<cfset returnedError["detail"] = arguments.cfcatch.getDetail() />

		<!--- TODO: REMOVE, FOR DEBUGGING ONLY --->
		<cfdump var="#returnedError#"><cfabort>

		<cfcontent reset="true" type="application/json" /><cfoutput>#serializeJSON(returnedError)#</cfoutput>
		<cfabort>
    </cffunction>

</cfcomponent>